* Problem statement
   A sorted list using a hashtable is a good data structure to implement a phone directory: given the name of the individual, find his phone number.
   Create an application that allows a user to edit, search, and print entries on a in memory buffer representing an address book. The data structure will be a SortedList – implementation on a hash table, collision resolution by separate chaining. From a textual menu the user will choose one of the following operations: insert, delete, search, list. Each entry will have a name, address, and a phone number.
   The problem with hash tables is that they don’t necessarily store the data in order. For example, if you have retrieved the phone number of “Smith, Jill”, you can’t expect the phone number of “Smith, John” to be nearby. 
This can be a big problem in practice. It is especially bad if the hash table is on a high-latency medium, like a spinning disk. But it can also hurt you if you have a gigantic hash table in RAM.
   
* Implementation

** Address Book

*** TItem
  | field        | field type |
  |--------------+------------|
  | name         | TString    |
  | phone_number | TString    |
  | address      | TString    |
  
  r@&
  == != ==>
**** AddressBook
  | field | field type |
  |-------+------------|
  | items | TItem[]    |
    
**** Operations
  #+BEGIN_SRC python
    subalgorithm init(addressBook, items) is:
    endsubalgorithm
  #+END_SRC python

  #+BEGIN_SRC python
    subalgorithm insert(addressBook, item) is:
    endsubalgorithm
  #+END_SRC python

  #+BEGIN_SRC python
    subalgorithm search(addressBook, item) is:
    endsubalgorithm
  #+END_SRC python

  #+BEGIN_SRC python
    subalgorithm delete(addressBook, item) is:
    endsubalgorithm
  #+END_SRC python

  #+BEGIN_SRC python
    subalgorithm list(addressBook) is:
    endsubalgorithm
  #+END_SRC python

** HashTable
   
*** HashTable
  | field      | field type |
  |------------+------------|
  | T          | TKey[]     |
  | next       | Integer[]  |
  | m          | Integer    |
  | firstFree  | Integer    |
  | h          | TFunction  |
    
    #+BEGIN_SRC
      subalgorithm insert (ht, k) is:
        //pre: ht is a HashTable, k is a TKey
        //post: k was added into ht
        pos ← ht.h(k)
        if ht.T[pos] = -1 then //-1 means empty position
          ht.T[pos] ← k
          ht.next[pos] ← -1
        else
          if ht.firstFree = ht.m then
            @resize and rehash
          end-if
          current ← pos
          while ht.next[current] 6= -1 execute
            current ← ht.next[current]
          end-while
          ht.T[ht.firstFree] ← k
          ht.next[ht.firstFree] ← - 1
          ht.next[current] ← ht.firstFree
          changeFirstFree(ht)
        end-if
      end-subalgorithm
    #+END_SRC

** Iterator Hash Table
   
*** IteratorHT
  | field        | field type |
  |--------------+------------|
  | ht:          | HashTable  |
  | currentPos:  | Integer    |
  | currentNode: | ↑Node      |
    
  #+BEGIN_SRC
    subalgorithm init(ith, ht) is:
      //pre: ith is an IteratorHT, ht is a HashTable
      ith.ht ← ht
      ith.currentPos ← 0
      while ith.currentPos < ht.m and ht.T[ith.currentPos] = NIL execute
        ith.currentPos ← ith.currentPos + 1
      end-while
      if ith.currentPos < ht.m then
        ith.currentNode ← ht.T[ith.currentPos]
      else
        ith.currentNode ← NIL
      end-if
    end-subalgorithm
  #+END_SRC
  
  #+BEGIN_SRC
  subalgorithm getCurrent(ith, elem) is:
    elem ← [ith.currentNode].key
  end-subalgorithm
  #+END_SRC

Sorted List ADT Specification
---
Structure:
The list elements are of ItemType. The list has a special property
called  the  
current  position
—the  position  of  the  last  element
accessed  by  
GetNextItem
during  an  iteration  through  the  list.
Only 
ResetList
and 
GetNextItem
affect the current position.
Definitions (provided by user in class ItemType):
MAX_ITEMS:
A  constant  specifying  the  maximum  number
of items in the list
RelationType:
An  enumeration  type  that  consists  of  LESS,
GREATER, EQUAL
Member function of ItemType that must be included:
RelationType ComparedTo(ItemType item)
Function:
Determines   the   ordering   of   two   ItemType
objects based on their keys.
Precondition:
Self and item have their key members initialized.
© Jones and Bartlett Publishers. NOT FOR SALE OR DISTRIBUTION
4.1 Abstract Data Type Sorted List
|
193
Postcondition:
Function value   = LESS if the key of self is less than the key of
item.
=  GREATER  if  the  key  of  self  is  greater  than
the key of item.
= EQUAL if the keys are equal.
Operations (provided by Sorted List ADT)
MakeEmpty
Function:
Initializes list to empty state.
Preconditions:
None
Postcondition:
List is empty.
Boolean IsFull
Function:
Determines whether list is full.
Precondition:
List has been initialized.
Postcondition:
Function value = (list is full)
int GetLength
Function:
Determines the number of elements in list.
Precondition:
List has been initialized.
Postcondition:
Function value = number of elements in list
RetrieveItem (ItemType& item , Boolean& found)
Function:
Retrieves   list   element   whose   key   matches
item’s key (if present).
Preconditions:
List has been initialized.
Key member of item is initialized.
Postconditions:
If  there  is  an  element  someItem  whose  key
matches  item’s  key,  then  found  =  true  and
item is a copy of someItem; otherwise found =
false and item is unchanged.
List is unchanged.
InsertItem (ItemType item )
Function:
Adds item to list.
Preconditions:
List has been initialized.
List is not full.
item is not in list.
List  is  sorted  by  key  member  using  function
ComparedTo.
Postconditions:
item is in list.
List is still sorted.
41582_CH04_DALECPP.qxd  9/22/06  11:04 AM  Page 193
© Jones and Bartlett Publishers. NOT FOR SALE OR DISTRIBUTION
194
|
Chapter 4:  ADT Sorted List
DeleteItem (ItemType item )
Function:
Deletes the element whose key matches item’s
key.
Preconditions:
List has been initialized.
Key member of item is initialized.
List  is  sorted  by  key  member  using  function
ComparedTo.
One  and  only  one  element  in  list  has  a  key
matching item’s key.
Postconditions:
No  element  in  list  has  key  matching  item’s
key.
List is still sorted.
ResetList
Function:
Initializes  current  position  for  an  iteration
through the list.
Precondition:
List has been initialized.
Postcondition:
Current position is prior to list.
GetNextItem (ItemType& item )
Function:
Gets the next element in list.
Preconditions:
List has been initialized.
Current position is defined.
Element at current position is not last in list.
Postconditions:
Current position is updated to next position.
item is a copy of element at current 
